#!/bin/bash
# 
# halogen is a simple source based package manager written in bash
# Copyright (C) 2015 Ilari Jääskeläinen
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.ddd
source /etc/halogen.conf &> /dev/null

# definitions
BUILD_FLAGS='CFLAGS="${CFLAGS}" CXXFLAGS="${CXXFLAGS}" LDFLAGS="${LDFLAGS}"'
SQLITE_REMOTE='sqlite3 $lib_path/sqlite.remote'
SQLITE_LOCAL='sqlite3 $lib_path/sqlite.local'

# lfs
export LFS=/mnt/lfs
export LFS_TGT=x86_64-pc-linux-gnu

# Enter working directory.
mkdir $TMP_PATH &> /dev/null
cd $TMP_PATH

#
# fix databases
#
function _aux_remote_db_touch {
	# sqlite3 ${REMOTE_DB} "UPDATE pkgs SET cfg = Replace(cfg, x'0D', '')"	# Disk I/O-error
	return 0;
}

#
# __build_get_sources package_id
#
function __build_get_sources() {
	echo "__build_get_sources(package_id)";
	_db_cached_results_pkg_pkg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT pkg FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_ver=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT ver FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_rev=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT rev FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_furl=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT furl FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_hash=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT hash FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg__build_get_sources_pre_hooks=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT __build_get_sources_pre_hooks FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg__build_get_sources_post_hooks=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT __build_get_sources_post_hooks FROM pkgs WHERE id=${1}"`
	# constants
	_file_path_checksum="${_db_cached_results_pkg_pkg}-${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev}.checksum"
	
	# pre
	$_db_cached_results_pkg__build_get_sources_pre_hooks
	# main
	echo "downloading ${_db_cached_results_pkg_pkg}-${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev} .."		# DOWNLOADING PACKAGE
	wget -q -N ${_db_cached_results_pkg_furl}																			# --
	
	rm -f $_file_path_checksum											# CHECKSUMMING PACKAGE
	echo "$_db_cached_results_pkg_hash" >> $_file_path_checksum			# --
	sha512sum -c $_file_path_checksum									# --
	while [[ $? != 0 ]]; do												# --
		echo "Checksum INVALID !!"										# --
		wget -q ${_db_cached_results_pkg_furl}							# --
	done;																# --
	echo "Checksum OK !!"												# --
	# post
	$_db_cached_results_pkg__build_get_sources_post_hooks
	return 0;
}
function __build_add_structure() {
	echo "__build_add_structure(package_id)"
	
	_db_cached_results_pkg_furl=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT furl FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg__build_add_structure_pre_hooks=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT __build_add_structure_pre_hooks FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg__build_add_structure_post_hooks=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT __build_add_structure_post_hooks FROM pkgs WHERE id=${1}"`
	
	$_db_cached_results_pkg__build_add_structure_pre_hooks
	
	_pkg_packagename=$(basename "$_db_cached_results_pkg_furl")
	_pkg_foldername="${_pkg_packagename%.*.*}"
	
	cd /tmp/halogen && rm -Rf ${_pkg_foldername} && tar -xf ${_pkg_packagename} && mkdir ${_pkg_foldername}/build && cd ${_pkg_foldername}/build
	
	$_db_cached_results_pkg__build_add_structure_post_hooks
	
	if [ $? -eq 0 ]; then
		return 0
	fi
	echo "__build_add_structure(${pkg_id}) failed"
	return -1
}
function __build_configure() {
	echo "__build_configure(package_id)";
	_db_cached_results_pkg_pkg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT pkg FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_ver=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT ver FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_rev=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT rev FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_cfg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT cfg FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_furl=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT furl FROM pkgs WHERE id=${1}"`
	_pkg_name="${_db_cached_results_pkg_pkg} (${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev})"

	# pre-hooks

	# main-hooks
	echo "Configuring ${_pkg_name}.."
	CFLAGS="${CFLAGS}" CXXFLAGS="${CFLAGS}" ../configure $_db_cached_results_pkg_cfg
	if [ $? -eq 0 ]; then
		# post-hooks
		return 0
	fi
    echo "__build_configure(${1}) failed!"
	return -1;
}
function __build_make() {
	echo "__build_make(package_id)";
	# pre-hooks
	# main-hooks
	CFLAGS="${CFLAGS}" CXXFLAGS="${CFLAGS}" make ${MAKEOPTS}
	if [ $? -eq 0 ]; then
		# post-hooks
		return 0
	fi
    echo "__build_check(${1}) failed!"
	# post-hooks
	return -1
}
function __build_check() {
	echo "__build_check(package_id)";
	# pre-hooks
	make ${MAKEOPTS} check
	if [ $? -eq 0 ]; then
		# post-hooks
		return 0
	fi
    echo "__build_check(${1}) failed!"
	return -1
}
function __build_install() {
	echo "__build_install(package_id)";
	# pre-hooks
	make install
	if [ $? -eq 0 ]; then
		# post-hooks
		return 0
	fi
    echo "__build_install(${1}) failed!"
	return -1
}
function __build_sanitize_structure() {
	echo "__build_del_structure(package_id)"
	
	_db_cached_results_pkg_furl=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT furl FROM pkgs WHERE id=${1}"`
	
	_pkg_packagename=$(basename "$_db_cached_results_pkg_furl")
	_pkg_foldername="${_pkg_packagename%.*.*}"
	
	cd /tmp/halogen && rm -Rf ${_pkg_foldername}
	return 0;
}
export -f __build_get_sources
export -f __build_add_structure
export -f __build_configure
export -f __build_make
export -f __build_check
#
# build; with databases; configure and build
#
function _build_package {
	echo "_build_package ID = ${pkg_id}";
	
	_db_cached_results_pkg_pkg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT pkg FROM pkgs WHERE id=${pkg_id}"`
	_db_cached_results_pkg_ver=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT ver FROM pkgs WHERE id=${pkg_id}"`
	_db_cached_results_pkg_rev=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT rev FROM pkgs WHERE id=${pkg_id}"`
	_pkg_name="${_db_cached_results_pkg_pkg} (${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev})"

	cd ${TMP_PATH}
	
	_db_cached_results_is_installed=`sqlite3 /var/lib/halogen/sqlite.local "SELECT count(*), * FROM pkgs WHERE pkg='${_db_cached_results_pkg_pkg}' AND ver='${_db_cached_results_pkg_ver}' AND rev='${_db_cached_results_pkg_rev}'"`
	if [[ $(echo ${_db_cached_results_is_installed} | awk '{split($0,a,"|"); print a[1]}') != "0" ]]; then
		echo "${_pkg_name} is already installed. rolling on.."
		export pkg_id=-1
	fi
	if [[ $(__build_get_sources ${pkg_id}) == -1 ]]; then
		export pkg_id=-1
		return -1;
	fi
	if [[ $(__build_add_structure ${pkg_id}) == -1 ]]; then
		export pkg_id=-1
		return -1;
	fi
	if [[ $(__build_configure ${pkg_id}) == -1 ]]; then
		export pkg_id=-1
		return -1;
	fi
	if [[ $(__build_make ${pkg_id}) == -1 ]]; then
		export pkg_id=-1
		return -1;
	fi
	if [[ $(__build_check ${pkg_id}) == -1 ]]; then
		export pkg_id=-1
		return -1;
	fi
	return 0;
}

export -f _build_package
function _build_package_root {
	__build_install ${pkg_id}
	__build_sanitize_structure ${pkg_id}
	return 0;
}
#
# simple build; without databases; in already configured build folder
#
function __build_package_simple {
	#
	__build_make -1
	__build_check -1
	__build_install -1
	
	cd /tmp/halogen
	
	return 0;
}
function _lfs_fetch_gcc_dependancies {
#	ls -v ../build &> /dev/null
#	if [ $? -eq 0 ]; then
#		echo "Fetching GCC dependancies..";
#		wget -q -N http://www.mpfr.org/mpfr-current/mpfr-3.1.5.tar.gz
#		wget -q -N https://ftp.gnu.org/gnu/gmp/gmp-6.1.1.tar.bz2
#		wget -q -N ftp://ftp.gnu.org/gnu/mpc/mpc-1.0.2.tar.gz
#		rm -Rf {../mpfr,../gmp,../mpc}
#		tar -xf mpfr-3.1.5.tar.gz && tar -xf gmp-6.1.1.tar.bz2 && tar -xf mpc-1.0.2.tar.gz
#		mv -f mpfr-3.1.5 ../mpfr && mv -f gmp-6.1.1 ../gmp && mv -f mpc-1.0.2 ../mpc
#		return 0;
#	fi
#   echo "_lfs_fetch_gcc_dependancies(null): script is in wrong folder.."
#   exit 1;
	return -1;
}
function _lfs_check_bootstrap_environment {
	# toolchain check
	export LC_ALL=C
	bash --version | head -n1 | cut -d" " -f2-4
	MYSH=$(readlink -f /bin/sh)
	echo "/bin/sh -> $MYSH"
	echo $MYSH | grep -q bash || echo "ERROR: /bin/sh does not point to bash"
	unset MYSH

	echo -n "Binutils: "; ld --version | head -n1 | cut -d" " -f3-
	bison --version | head -n1

	if [ -h /usr/bin/yacc ]; then
	  echo "/usr/bin/yacc -> `readlink -f /usr/bin/yacc`";
	elif [ -x /usr/bin/yacc ]; then
	  echo yacc is `/usr/bin/yacc --version | head -n1`
	else
	  echo "yacc not found" 
	fi

	bzip2 --version 2>&1 < /dev/null | head -n1 | cut -d" " -f1,6-
	echo -n "Coreutils: "; chown --version | head -n1 | cut -d")" -f2
	diff --version | head -n1
	find --version | head -n1
	gawk --version | head -n1

	if [ -h /usr/bin/awk ]; then
	  echo "/usr/bin/awk -> `readlink -f /usr/bin/awk`";
	elif [ -x /usr/bin/awk ]; then
	  echo awk is `/usr/bin/awk --version | head -n1`
	else 
	  echo "awk not found" 
	fi

	gcc --version | head -n1
	g++ --version | head -n1
	ldd --version | head -n1 | cut -d" " -f2-  # glibc version
	grep --version | head -n1
	gzip --version | head -n1
	cat /proc/version
	m4 --version | head -n1
	make --version | head -n1
	patch --version | head -n1
	echo Perl `perl -V:version`
	sed --version | head -n1
	tar --version | head -n1
	makeinfo --version | head -n1
	xz --version | head -n1

	echo 'int main(){}' > dummy.c && g++ -o dummy dummy.c
	if [ -x dummy ]
	  then echo "g++ compilation OK";
	  else echo "g++ compilation failed"; fi
	rm -f dummy.c dummy
	
	# lib check
	for lib in lib{gmp,mpfr,mpc}.la; do
	echo $lib: $(if find /usr/lib* -name $lib|
		grep -q $lib;then :;else echo not;fi) found
	done
	unset lib
	
	while true; do
    read -p "** warning: are you sure your bootstrap environment is ready? **" yn
    case $yn in
        [Yy]* ) break;;
        [Nn]* ) exit;;
        * ) echo "please answer yes or no.";;
    esac
	done
}
function _lfs_prepare_disks {
	mkdir -pv $LFS							# create new root
	mount -v -t ext4 $BOOTSTRAP_ROOT $LFS	# mount new root
	/sbin/swapon -v $BOOTSTRAP_SWAP			# mount new swapon
	mkdir -v $LFS/sources					# create temp folders 
	chmod -v a+wt $LFS/sources				# change temp folder permissions
	mkdir -v $LFS/tools						# create temp folders
	ln -sv $LFS/tools /						# create temp folders symlink
	groupadd lfs							# create user
	useradd -s /bin/bash -g lfs -m -k /dev/null lfs	# modify user shell
	passwd lfs								# change user password
	chown -vR lfs /home/lfs &> /dev/null	# just in case
	chown -v lfs $LFS/tools					# change temp folder permissions
	chown -v lfs $LFS/sources				# change temp folder permissions
	echo "To continue, please run:"
	echo "su -l lfs"									#
	echo "su -c '/usr/local/bin/halogen update' root"	# guide
	echo "halogen bootstrap-internal-one"				#
}
function _lfs_prepare_user {
	while true; do
		read -p "Install default .bashrc and .bash_profile for use lfs?" yn
		case $yn in
			[Yy]* ) break;;
			[Nn]* ) return 0;;
			* ) echo "yes or no.";;
		esac
	done
	rm /home/lfs/.bashrc
	rm /home/lfs/.bash_profile
	cp -f /tmp/halogen/.bashrc /home/lfs/.bashrc
	cp -f /tmp/halogen/.bash_profile /home/lfs/.bash_profile
	export MAKEFLAGS="-j5"
	return 1;
}
function _lfs_bootstrap_internal_one {
	echo "_lfs_bootstrap_internal_one(null)"
	_aux_remote_db_touch;
	
	_db_cached_results_pkg_id=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT id FROM pkgs WHERE 1 ORDER BY id ASC"`

	for pkg_id in $_db_cached_results_pkg_id; do
		if [ -z "$pkg_id" ]; then
			echo "Halogen package manager is complete!"
			exit 0
		fi
		
		export pkg_id=${pkg_id}
		
		_db_cached_results_pkg_pkg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT pkg FROM pkgs WHERE id=${pkg_id}"`
		_db_cached_results_pkg_ver=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT ver FROM pkgs WHERE id=${pkg_id}"`
		_db_cached_results_pkg_rev=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT rev FROM pkgs WHERE id=${pkg_id}"`
		_db_cached_results_pkg_cfg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT cfg FROM pkgs WHERE id=${pkg_id}"`
		
		echo {$_db_cached_results_pkg_pkg,$_db_cached_results_pkg_ver,$_db_cached_results_pkg_rev,$_db_cached_results_pkg_cfg}
		
		su lfs -c "bash -c $(_build_package $((${pkg_id})))"	# download, hash, fold, configure, build and check as normal user
		if [ $? -eq 0 ]; then
			exit 1
		fi
		if [[ ${pkg_id} == -1 ]]; then
			echo "usermode build failed!"
			exit 1
		fi
		_build_package_root ${pkg_id}
		
		sqlite3 /var/lib/halogen/sqlite.local "INSERT INTO pkgs (pkg, ver, rev) VALUES ('${_db_cached_results_pkg_pkg}', '${_db_cached_results_pkg_ver}', '${_db_cached_results_pkg_rev}')"
	done
	return 0;
}
case $1 in
  update)
	if [ "$EUID" -ne 0 ]; then
	   echo "please run halogen update as root"
	   exit
	fi
	echo "Updating scripts .. (does not work)"
	# wget -q -O /usr/local/bin/halogen https://raw.githubusercontent.com/nafac/halogen/master/usr/local/bin/halogen
	chmod +x /usr/local/bin/halogen
	mkdir /var/lib/halogen &> /dev/null
	chmod -R 1777 /var/lib/halogen
	echo "Updating package database .. (does not work)"
	# wget -q -O  /var/lib/halogen/sqlite.remote https://github.com/nafac/halogen/raw/master/var/lib/halogen/sqlite.remote
    exit ;;
#  bootstrap-update-host-toolchain)
#	echo "downloading binutils and dependancies.."
#	cd /tmp/halogen
#	wget -q -N https://ftp.gnu.org/gnu/binutils/binutils-2.26.1.tar.gz
#	rm -Rf binutils-2.26.1
#	tar -xf binutils-2.26.1.tar.gz
#	mkdir binutils-2.26.1/build
#	cd binutils-2.26.1/build
#	echo "configuring binutils.."
#	../configure --prefix=/usr --enable-shared --disable-werror
#	if [ $? -eq 0 ]; then
#		__build_package_simple
#	else
#		echo "Failed to configure!"
#		exit 1
#	fi
#	echo "downloading glibc and dependancies.."
#	cd /tmp/halogen
#	wget -q -N https://ftp.gnu.org/gnu/glibc/glibc-2.24.tar.gz
#	rm -Rf glibc-2.24
#	tar -xf glibc-2.24.tar.gz
#	mkdir glibc-2.24/build
#	cd glibc-2.24/build
#	echo "configuring glibc.."
#	../configure --prefix=/usr --enable-kernel=4.4.25 --enable-obsolete-rpc
#	if [ $? -eq 0 ]; then
#		__build_package_simple
#	else
#		echo "Failed to configure!"
#		exit 1
#	fi

#	echo "downloading gcc and dependancies.."
#	cd /tmp/halogen
#	wget -q -N https://ftp.gnu.org/pub/gnu/gcc/gcc-6.2.0/gcc-6.2.0.tar.gz
#	_lfs_fetch_gcc_dependancies
#	echo "oonfiguring gcc.."
#	../configure -v --enable-languages=c,c++,go,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --enable-plugin --enable-objc-gc --with-arch-32=i686 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --disable-multilib --disable-bootstrap
#	if [ $? -eq 0 ]; then
#		__build_package_simple
#	else
#		echo "Failed to configure!"
#		exit 1
#	fi
#	exit ;;
  bootstrap) 
	_lfs_check_bootstrap_environment;
	_lfs_prepare_disks;
	_lfs_prepare_user;
	exit ;;
  bootstrap-internal-one) 
  	if [ "$EUID" -ne 0 ]; then
	   echo "please run halogen bootstrap-internal-one as root"
	   echo "download, build and check will always be executed as user 'lfs'"
	   exit
	fi
	_lfs_bootstrap_internal_one;
	exit ;;
  build-base)
    # query="SELECT * FROM packages_base WHERE 1"
    # commit=`sqlite3 $lib_path/halogen.db "$query";
    
    # echo $commit
    
    # for row in $commit; do
      # if [ -z "$row" ]; then
        # echo "Halogen is (propably) complete!"
        # exit 0
      # fi
      
      # export pkg_name=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      # export pkg_status=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      
      # source $lib_path/pkg/$pkg_name
      
      # echo $pkg_name
      # echo $pkg_status
      
      # if [ "$pkg_status" == installed ]; then
        # echo "Package $pkg_name is already installed, skipping." 
        # continue
      # fi
     
      # rm -Rf "${pkg_name}"
      # rm -Rf "${pkg_name}-build"
      
      # echo "Downloading package $pkg_name ..."
      # wget -nc -q -O $pkg_name $furl
      
      # echo "Extracting package $pkg_name ..."
      # halogenzip ${pkg_name}
      # mkdir "${pkg_name}-build"
      # cd "${pkg_name}-build"
      
      # continue
      
      # echo "Patching ..."
      # # pre hook
      
      # echo "Configuring archives of $pkg_name ..."
      # echo $Conf
      # ../$pkg_name/configure $Conf CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS"
      
      # echo "Building package of $pkg_name ..."
      # echo "CFLAGS=$CFLAGS CXXFLAGS=$CXXFLAGS"
      # make CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS"
      
      # if [ "$_make_check" -eq "1" ]; then
	# return 1
      # fi
      
      # $Id=$Id+1
      # if [ $? -eq 0 ] ; then
        # echo "Installing package $pkg_name ..."
        # sudo make install
        # if [ $? -eq 0 ] ; then
          # sqlite3 $lib_path/remote.db "UPDATE base_packages SET status = 'Installed' WHERE id = $Id";
        # else
          # echo "$pkg_name - make install failed!"
          # exit 1
        # fi
      # else
        # echo "$pkg_name - make check failed!"
        # exit 1
      # fi
      
      # cd /tmp/halogen
    # done
    # exit 0;;
  # optimize-debian)
    # query="SELECT packages FROM packages_base_debian WHERE 1"
    # commit=`sqlite3 $lib_path/halogen.db "$query"`;
    
    # IFS=$'\n'
    # _lines=($commit)
    
    # for row in ${_lines[@]}; do 
      # query="SELECT opt FROM packages_base_debian WHERE packages='$row'"
      # export _opti=`sqlite3 $lib_path/halogen.db "$query"`;
      
      # IFS=$' '
      # _packages=($row)

      # for _package in ${_packages[@]}; do
        # cd $tmp_path
        
        # _query="SELECT EXISTS(SELECT 1 FROM packages_installed WHERE package = '$_package' LIMIT 1);"
        # _installed=`sqlite3 $lib_path/halogen.db "$_query"`;
        
        # echo "package = $_package - installed = $_installed - optimize = $_opti"
        
        # if [ "$_installed" -eq "1" ]; then
          # echo "$_package is already installed."
          # continue
        # fi
        
        # echo "fetching $_package .."
        # apt-src install $_package
        
        # unset $IFS
        # cd ${tmp_path}/${_package}*
        
        # if _make_build $_opti; then
          # echo
        # else
          # continue
        # fi
        # if _make_check; then
          # echo
        # else
          # continue
        # fi
        # if _make_install; then
          # sqlite3 $lib_path/halogen.db "INSERT INTO packages_installed (package) VALUES ('$_package')";
        # else
          # continue
        # fi
        # continue
      # done
    # done
    exit ;;
  resume)
	exit ;;
  *)
    exit ;;
esac
