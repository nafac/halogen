#!/bin/bash
# 
# halogen is a simple source based package manager written in bash
# Copyright (C) 2015 Ilari Jääskeläinen
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.ddd
source /etc/halogen.conf &> /dev/null

# definitions
BUILD_FLAGS='CFLAGS="${CFLAGS}" CXXFLAGS="${CXXFLAGS}" LDFLAGS="${LDFLAGS}"'
SQLITE_REMOTE='sqlite3 $lib_path/sqlite.remote'
SQLITE_LOCAL='sqlite3 $lib_path/sqlite.local'

# lfs
export LFS=/mnt/lfs
export LFS_TGT=x86_64-lfs-linux-gnu

# Unorthodox way to check package manager dependancies.
hash sqlite3 2> /dev/null || { echo >&2 "sqlite3 is required to run halogen. Aborting."; exit 1; }
hash wget 2> /dev/null || { echo >&2 "wget is required to run halogen. Aborting."; exit 1; }
hash rsync 2> /dev/null || { echo >&2 "rsync is required to run halogen. Aborting."; exit 1; }

# Enter working directory.
mkdir $tmp_path &> /dev/null
cd $tmp_path

# auxiliary
function _aux_remote_db_touch {
	echo "Touching ${REMOTE_DB} .."
	# sqlite3 ${REMOTE_DB} "UPDATE pkgs SET cfg = Replace(cfg, x'0D', '')"	# Disk I/O-error
}

#
# __build_get_sources package_id
#
function __build_get_sources {
	echo "__build_get_sources(package_id)";
	_db_cached_results_pkg_pkg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT pkg FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_ver=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT ver FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_rev=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT rev FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_furl=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT furl FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_hash=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT hash FROM pkgs WHERE id=${1}"`
	_file_path_checksum="${_db_cached_results_pkg_pkg}-${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev}.checksum"
	
	# pre-hooks
	# main-hooks
	echo "downloading ${_db_cached_results_pkg_pkg}-${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev} .."
	wget -q -N ${_db_cached_results_pkg_furl}
	
	# create checksum file from db
	rm -f $_file_path_checksum
	echo "$_db_cached_results_pkg_hash" >> $_file_path_checksum
	
	# checksumming
	sha512sum -c $_file_path_checksum
	while [[ $? != 0 ]]; do
		echo "Checksum INVALID !!"
		wget -q ${_db_cached_results_pkg_furl}
	done;
	echo "Checksum OK !!"
	
	filename=$(basename "$_db_cached_results_pkg_furl")
	filename="${filename%.*}"
	rm -Rf $filename
	tar -xf $(basename "${_db_cached_results_pkg_furl}")
	# post-hooks
	return 0;
}
function __build_configure {
	echo "__build_configure()";
	_db_cached_results_pkg_pkg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT pkg FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_ver=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT ver FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_rev=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT rev FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_cfg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT cfg FROM pkgs WHERE id=${1}"`
	_db_cached_results_pkg_furl=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT furl FROM pkgs WHERE id=${1}"`
	_pkg_name="${_db_cached_results_pkg_pkg} (${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev})"
	# pre-hooks
	# main-hooks
	echo "configuring $_pkg_name .."
	filename=$(basename "$_db_cached_results_pkg_furl")
	filename="${filename%.*.*}"
	cd /tmp/halogen && cd $filename && mkdir build
	cd build
	CFLAGS="${CFLAGS}" CXXFLAGS="${CFLAGS}" ../configure $_db_cached_results_pkg_cfg
	# post-hooks
	return 0;
}
function __build_make {
	echo "__build_make(package_id)";
	# pre-hooks
	# main-hooks
	make ${MAKEOPTS}
	# post-hooks
	return 0;
}
function __build_check {
	echo "__build_check(package_id)";
	# pre-hooks
	# main-hooks
	make ${MAKEOPTS} check
	if [ $? -eq 0 ]; then
		# post-hooks
		return 0
	fi
    echo "__build_check(${1}) failed!"
    exit 1;
}
function __build_install {
	echo "__build_install(package_id)";
	# pre-hooks
	# main-hooks
	# post-hooks
	return 0;
}
function _build_package {
	echo "_build_package ID=${1}";
	
	cd ${TMP_PATH}
	
	__build_get_sources ${1}
	__build_configure ${1}
	__build_make ${1}
	__build_check ${1}
	__build_install ${1}
	
	# echo "fetching $_package .."
	# apt-src install $_package
        
	# unset $IFS
	# cd ${tmp_path}/${_package}*
        
	# if _make_build $_opti; then
		# echo
	# else
		# continue
	# fi
	# if _make_check; then
		# echo
	# else
		# continue
	# fi
	# if _make_install; then
		# sqlite3 $lib_path/halogen.db "INSERT INTO packages_installed (package) VALUES ('$_package')";
	# else
		# continue
	# fi
	
	cd ~
	
	return 0;
}

# old
function _make_build {
  echo "configuring .."
  ./configure ${BUILD_FLAGS}
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
  echo "building .."
  make -j5 ${BUILD_FLAGS}
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
}
function _make_check {
  echo "Testing package .."
  make -j5 check
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
  sudo make check
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
}
function _make_install {
  echo "Installing package .."
  sudo make install
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
}
# post

# Linux From Scratch
function _lfs_check_bootstrap_environment {
	# toolchain check
	export LC_ALL=C
	bash --version | head -n1 | cut -d" " -f2-4
	MYSH=$(readlink -f /bin/sh)
	echo "/bin/sh -> $MYSH"
	echo $MYSH | grep -q bash || echo "ERROR: /bin/sh does not point to bash"
	unset MYSH

	echo -n "Binutils: "; ld --version | head -n1 | cut -d" " -f3-
	bison --version | head -n1

	if [ -h /usr/bin/yacc ]; then
	  echo "/usr/bin/yacc -> `readlink -f /usr/bin/yacc`";
	elif [ -x /usr/bin/yacc ]; then
	  echo yacc is `/usr/bin/yacc --version | head -n1`
	else
	  echo "yacc not found" 
	fi

	bzip2 --version 2>&1 < /dev/null | head -n1 | cut -d" " -f1,6-
	echo -n "Coreutils: "; chown --version | head -n1 | cut -d")" -f2
	diff --version | head -n1
	find --version | head -n1
	gawk --version | head -n1

	if [ -h /usr/bin/awk ]; then
	  echo "/usr/bin/awk -> `readlink -f /usr/bin/awk`";
	elif [ -x /usr/bin/awk ]; then
	  echo awk is `/usr/bin/awk --version | head -n1`
	else 
	  echo "awk not found" 
	fi

	gcc --version | head -n1
	g++ --version | head -n1
	ldd --version | head -n1 | cut -d" " -f2-  # glibc version
	grep --version | head -n1
	gzip --version | head -n1
	cat /proc/version
	m4 --version | head -n1
	make --version | head -n1
	patch --version | head -n1
	echo Perl `perl -V:version`
	sed --version | head -n1
	tar --version | head -n1
	makeinfo --version | head -n1
	xz --version | head -n1

	echo 'int main(){}' > dummy.c && g++ -o dummy dummy.c
	if [ -x dummy ]
	  then echo "g++ compilation OK";
	  else echo "g++ compilation failed"; fi
	rm -f dummy.c dummy
	
	# lib check
	for lib in lib{gmp,mpfr,mpc}.la; do
	echo $lib: $(if find /usr/lib* -name $lib|
		grep -q $lib;then :;else echo not;fi) found
	done
	unset lib
	
	while true; do
    read -p "** warning: are you sure your bootstrap environment is ready? **" yn
    case $yn in
        [Yy]* ) break;;
        [Nn]* ) exit;;
        * ) echo "please answer yes or no.";;
    esac
	done
}
function _lfs_prepare_disks {
	mkdir -pv $LFS							# create new root
	mount -v -t ext4 $BOOTSTRAP_ROOT $LFS	# mount new root
	/sbin/swapon -v $BOOTSTRAP_SWAP			# mount new swapon
	mkdir -v $LFS/sources					# create temp folders 
	chmod -v a+wt $LFS/sources				# change temp folder permissions
	mkdir -v $LFS/tools						# create temp folders
	ln -sv $LFS/tools /						# create temp folders symlink
	groupadd lfs							# create user
	useradd -s /bin/bash -g lfs -m -k /dev/null lfs	# modify user shell
	passwd lfs								# change user password
	chown -vR lfs /home/lfs &> /dev/null	# just in case
	chown -v lfs $LFS/tools					# change temp folder permissions
	chown -v lfs $LFS/sources				# change temp folder permissions
	echo "To continue, please run:"
	echo "su -l lfs"									#
	echo "su -c '/usr/local/bin/halogen update' root"	# guide
	echo "halogen bootstrap-internal-one"				#
}
function _lfs_prepare_user {
	while true; do
		read -p "Install default .bashrc and .bash_profile for use lfs?" yn
		case $yn in
			[Yy]* ) break;;
			[Nn]* ) return 0;;
			* ) echo "yes or no.";;
		esac
	done
	rm /home/lfs/.bashrc
	rm /home/lfs/.bash_profile
	cp -f /tmp/halogen/.bashrc /home/lfs/.bashrc
	cp -f /tmp/halogen/.bash_profile /home/lfs/.bash_profile
	export MAKEFLAGS="-j5"
	return 1;
}

function _lfs_bootstrap_internal_one {
	_aux_remote_db_touch;
	echo "debug #2"
	# build process
	_db_cached_results_pkg_id=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT id FROM pkgs WHERE 1"`
	echo "debug #3"
	for row in $_db_cached_results_pkg_id; do
		echo "debug #3"
		echo $row;
		if [ -z "$row" ]; then
			echo "Halogen package manager is complete!"
			exit 0
		fi
		
		_db_cached_results_pkg_pkg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT pkg FROM pkgs WHERE id=${row}"`
		_db_cached_results_pkg_ver=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT ver FROM pkgs WHERE id=${row}"`
		_db_cached_results_pkg_rev=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT rev FROM pkgs WHERE id=${row}"`
		_db_cached_results_pkg_cfg=`sqlite3 /var/lib/halogen/sqlite.remote "SELECT cfg FROM pkgs WHERE id=${row}"`
		
		echo "debug #4"
	
		echo "Working on ${_db_cached_results_pkg_pkg} (${_db_cached_results_pkg_ver}r${_db_cached_results_pkg_rev})"
		echo "config: $_db_cached_results_pkg_cfg"
		
		_build_package ${row};
	done
	return 0;
}

case $1 in
  update)
	if [ "$EUID" -ne 0 ]; then
	   echo "please run halogen update as root"
	   exit
	fi
	echo "Updating scripts .."
	wget -q -O /usr/local/bin/halogen https://raw.githubusercontent.com/nafac/halogen/master/usr/local/bin/halogen
	chmod +x /usr/local/bin/halogen
	mkdir /var/lib/halogen &> /dev/null
	chmod -R 1777 /var/lib/halogen
	echo "Updating package database .."
	wget -q -O -O /var/lib/halogen/sqlite.remote https://github.com/nafac/halogen/raw/master/var/lib/halogen/sqlite.remote
    exit ;;
  bootstrap-update-host-toolchain)
	cd /tmp/halogen
	echo "downloading gcc and dependancies.."
	wget -q -N https://ftp.gnu.org/pub/gnu/gcc/gcc-6.2.0/gcc-6.2.0.tar.gz
	wget -q -N http://www.mpfr.org/mpfr-current/mpfr-3.1.5.tar.gz
	wget -q -N https://ftp.gnu.org/gnu/gmp/gmp-6.1.1.tar.bz2
	wget -q -N ftp://ftp.gnu.org/gnu/mpc/mpc-1.0.2.tar.gz
	echo "extracting gcc and dependancies.."
	rm -Rf {gcc-6.2.0,mpfr-3.1.5,gmp-6.1.1,mpc-1.0.2}
	tar -xf gcc-6.2.0.tar.gz && tar -xf mpfr-3.1.5.tar.gz && tar -xf gmp-6.1.1.tar.bz2 && tar -xf mpc-1.0.2.tar.gz
	mkdir -p gcc-6.2.0/{mpfr,gmp,mpc}
	mv -f mpfr-3.1.5 gcc-6.2.0/mpfr && mv -f gmp-6.1.1 gcc-6.2.0/gmp && mv -f mpc-1.0.2 gcc-6.2.0/mpc
	mkdir -v -p gcc-6.2.0/build
	cd gcc-6.2.0/build
	echo "oonfiguring gcc.."
	../configure -v --enable-languages=c,c++,go,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --enable-plugin --enable-objc-gc --with-arch-32=i686 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --disable-multilib --disable-bootstrap
	if [ $? -eq 0 ]; then
		# post-hooks
		echo "building gcc.."
		make ${MAKEOPTS}
		if [ $? -eq 0 ]; then
			# post-hooks
			echo "checking gcc.."
			make ${MAKEOPTS} check
			if [ $? -eq 0 ]; then
				# post-hooks
				echo "installing gcc.."
				make ${MAKEOPTS} install
				if [ $? -eq 0 ]; then
					echo "SUCCESSFULLY INSTALLED GCC 6.2.0"
					gcc -v
					exit 0
				else
					echo "FAILED TO INSTALL GCC 6.2.0"
					exit 1
				fi
			else
				echo "failed to check gcc!!"
				exit 1
			fi
		else
			echo "failed to build gcc!!"
			exit 1
		fi
	else
		echo "failed to configure gcc!!"
		exit 1
	fi
	exit ;;
  bootstrap) 
	_lfs_check_bootstrap_environment;
	_lfs_prepare_disks;
	_lfs_prepare_user;
	exit ;;
  bootstrap-internal-one) 
	_lfs_bootstrap_internal_one;
	exit ;;
  build-base)
    # query="SELECT * FROM packages_base WHERE 1"
    # commit=`sqlite3 $lib_path/halogen.db "$query";
    
    # echo $commit
    
    # for row in $commit; do
      # if [ -z "$row" ]; then
        # echo "Halogen is (propably) complete!"
        # exit 0
      # fi
      
      # export pkg_name=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      # export pkg_status=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      
      # source $lib_path/pkg/$pkg_name
      
      # echo $pkg_name
      # echo $pkg_status
      
      # if [ "$pkg_status" == installed ]; then
        # echo "Package $pkg_name is already installed, skipping." 
        # continue
      # fi
     
      # rm -Rf "${pkg_name}"
      # rm -Rf "${pkg_name}-build"
      
      # echo "Downloading package $pkg_name ..."
      # wget -nc -q -O $pkg_name $furl
      
      # echo "Extracting package $pkg_name ..."
      # halogenzip ${pkg_name}
      # mkdir "${pkg_name}-build"
      # cd "${pkg_name}-build"
      
      # continue
      
      # echo "Patching ..."
      # # pre hook
      
      # echo "Configuring archives of $pkg_name ..."
      # echo $Conf
      # ../$pkg_name/configure $Conf CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS"
      
      # echo "Building package of $pkg_name ..."
      # echo "CFLAGS=$CFLAGS CXXFLAGS=$CXXFLAGS"
      # make CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS"
      
      # if [ "$_make_check" -eq "1" ]; then
	# return 1
      # fi
      
      # $Id=$Id+1
      # if [ $? -eq 0 ] ; then
        # echo "Installing package $pkg_name ..."
        # sudo make install
        # if [ $? -eq 0 ] ; then
          # sqlite3 $lib_path/remote.db "UPDATE base_packages SET status = 'Installed' WHERE id = $Id";
        # else
          # echo "$pkg_name - make install failed!"
          # exit 1
        # fi
      # else
        # echo "$pkg_name - make check failed!"
        # exit 1
      # fi
      
      # cd /tmp/halogen
    # done
    # exit 0;;
  # optimize-debian)
    # query="SELECT packages FROM packages_base_debian WHERE 1"
    # commit=`sqlite3 $lib_path/halogen.db "$query"`;
    
    # IFS=$'\n'
    # _lines=($commit)
    
    # for row in ${_lines[@]}; do 
      # query="SELECT opt FROM packages_base_debian WHERE packages='$row'"
      # export _opti=`sqlite3 $lib_path/halogen.db "$query"`;
      
      # IFS=$' '
      # _packages=($row)

      # for _package in ${_packages[@]}; do
        # cd $tmp_path
        
        # _query="SELECT EXISTS(SELECT 1 FROM packages_installed WHERE package = '$_package' LIMIT 1);"
        # _installed=`sqlite3 $lib_path/halogen.db "$_query"`;
        
        # echo "package = $_package - installed = $_installed - optimize = $_opti"
        
        # if [ "$_installed" -eq "1" ]; then
          # echo "$_package is already installed."
          # continue
        # fi
        
        # echo "fetching $_package .."
        # apt-src install $_package
        
        # unset $IFS
        # cd ${tmp_path}/${_package}*
        
        # if _make_build $_opti; then
          # echo
        # else
          # continue
        # fi
        # if _make_check; then
          # echo
        # else
          # continue
        # fi
        # if _make_install; then
          # sqlite3 $lib_path/halogen.db "INSERT INTO packages_installed (package) VALUES ('$_package')";
        # else
          # continue
        # fi
        # continue
      # done
    # done
    exit ;;
  resume)
	exit ;;
  *)
    exit ;;
esac