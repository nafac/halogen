#!/bin/bash
# 
# halogen is a simple source based package manager written in bash
# Copyright (C) 2015 Ilari Jääskeläinen
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.ddd
source /etc/halogen.conf &> /dev/null

# definitions
BUILD_FLAGS='CFLAGS="${CFLAGS}" CXXFLAGS="${CXXFLAGS}" LDFLAGS="${LDFLAGS}"'
SQLITE_REMOTE='sqlite3 $lib_path/sqlite.remote'
SQLITE_LOCAL='sqlite3 $lib_path/sqlite.local'

# lfs
export LFS=/mnt/lfs

# Unorthodox way to check package manager dependancies.
hash sqlite3 2> /dev/null || { echo >&2 "sqlite3 is required to run halogen. Aborting."; exit 1; }
hash wget 2> /dev/null || { echo >&2 "wget is required to run halogen. Aborting."; exit 1; }
hash rsync 2> /dev/null || { echo >&2 "rsync is required to run halogen. Aborting."; exit 1; }

# Enter working directory.
mkdir $tmp_path &> /dev/null
cd $tmp_path

# Load functions at the beginning of the script.
function _wget_source {
  return 0
}
function _make_build {
  echo "configuring .."
  ./configure ${BUILD_FLAGS}
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
  echo "building .."
  make -j5 ${BUILD_FLAGS}
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
}
function _make_check {
  echo "Testing package .."
  make -j5 check
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
  sudo make check
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
}
function _make_install {
  echo "Installing package .."
  sudo make install
  if [ $? -eq 0 ] ; then
    return 0
  else
    echo "failed!"
    return 1
  fi
}
# post

# Linux From Scratch
function _lfs_check_bootstrap_environment {
	# toolchain check
	export LC_ALL=C
	bash --version | head -n1 | cut -d" " -f2-4
	MYSH=$(readlink -f /bin/sh)
	echo "/bin/sh -> $MYSH"
	echo $MYSH | grep -q bash || echo "ERROR: /bin/sh does not point to bash"
	unset MYSH

	echo -n "Binutils: "; ld --version | head -n1 | cut -d" " -f3-
	bison --version | head -n1

	if [ -h /usr/bin/yacc ]; then
	  echo "/usr/bin/yacc -> `readlink -f /usr/bin/yacc`";
	elif [ -x /usr/bin/yacc ]; then
	  echo yacc is `/usr/bin/yacc --version | head -n1`
	else
	  echo "yacc not found" 
	fi

	bzip2 --version 2>&1 < /dev/null | head -n1 | cut -d" " -f1,6-
	echo -n "Coreutils: "; chown --version | head -n1 | cut -d")" -f2
	diff --version | head -n1
	find --version | head -n1
	gawk --version | head -n1

	if [ -h /usr/bin/awk ]; then
	  echo "/usr/bin/awk -> `readlink -f /usr/bin/awk`";
	elif [ -x /usr/bin/awk ]; then
	  echo awk is `/usr/bin/awk --version | head -n1`
	else 
	  echo "awk not found" 
	fi

	gcc --version | head -n1
	g++ --version | head -n1
	ldd --version | head -n1 | cut -d" " -f2-  # glibc version
	grep --version | head -n1
	gzip --version | head -n1
	cat /proc/version
	m4 --version | head -n1
	make --version | head -n1
	patch --version | head -n1
	echo Perl `perl -V:version`
	sed --version | head -n1
	tar --version | head -n1
	makeinfo --version | head -n1
	xz --version | head -n1

	echo 'int main(){}' > dummy.c && g++ -o dummy dummy.c
	if [ -x dummy ]
	  then echo "g++ compilation OK";
	  else echo "g++ compilation failed"; fi
	rm -f dummy.c dummy
	
	# lib check
	for lib in lib{gmp,mpfr,mpc}.la; do
	echo $lib: $(if find /usr/lib* -name $lib|
		grep -q $lib;then :;else echo not;fi) found
	done
	unset lib
	
	while true; do
    read -p "** warning: are you sure your bootstrap environment is ready? **" yn
    case $yn in
        [Yy]* ) break;;
        [Nn]* ) exit;;
        * ) echo "please answer yes or no.";;
    esac
	done
}
function _lfs_prepare_disks {
	mkdir -pv $LFS							# create new root
	mount -v -t ext4 $BOOTSTRAP_ROOT $LFS	# mount new root
	/sbin/swapon -v $BOOTSTRAP_SWAP			# mount new swapon
	mkdir -v $LFS/sources					# create temp folders 
	chmod -v a+wt $LFS/sources				# change temp folder permissions
	mkdir -v $LFS/tools						# create temp folders
	ln -sv $LFS/tools /						# create temp folders symlink
	groupadd lfs							# create user
	useradd -s /bin/bash -g lfs -m -k /dev/null lfs	# modify user shell
	passwd lfs								# change user password
	chown -v lfs $LFS/tools					# change temp folder permissions
	chown -v lfs $LFS/sources				# change temp folder permissions
	echo "To continue, please run:"
	echo "su -l lfs"									#
	echo "su -c '/usr/local/bin/halogen update' root"	#
	echo "/usr/local/bin/halogen bootstrap-lfs"			#
}

case $1 in
  update)
	if [ "$EUID" -ne 0 ]; then
	   echo "please run halogen update as root"
	   exit
	fi
	wget https://github.com/nafac/halogen/raw/master/usr/local/bin/halogen -O /usr/local/bin/halogen
	chmod +x /usr/local/bin/halogen
	mkdir /var/lib/halogen
	chmod -R 1777 /var/lib/halogen
	wget https://github.com/nafac/halogen/raw/master/var/lib/halogen/sqlite.remote -O /var/lib/halogen/sqlite.remote
    exit ;;
  bootstrap) 
	_lfs_check_bootstrap_environment;
	_lfs_prepare_disks;
	exit ;;
  bootstrap-lfs)
	# configure environment
	rm ~/.bashrc
	rm ~/.bash_profile
	cp -f /tmp/halogen/.bashrc ~/.bashrc
	cp -f /tmp/halogen/.bash_profile ~/.bash_profile
	source /home/lfs/.bash_profile
	export MAKEFLAGS='-j5'
	# build
	query = "SELECT * FROM pkgs WHERE 1"
	db_cached_pkgs = `${SQLITE_REMOTE} ${query}`
	for row in ${db_cached_pkgs}; do
		echo $row;
		if [ -z "$row" ]; then
			echo "Halogen is (propably) complete!"
			exit 0
		fi
	done
	exit ;;

  # build-base)
    # query="SELECT * FROM packages_base WHERE 1"
    # commit=`sqlite3 $lib_path/halogen.db "$query";
    
    # echo $commit
    
    # for row in $commit; do
      # if [ -z "$row" ]; then
        # echo "Halogen is (propably) complete!"
        # exit 0
      # fi
      
      # export pkg_name=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      # export pkg_status=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      
      # source $lib_path/pkg/$pkg_name
      
      # echo $pkg_name
      # echo $pkg_status
      
      # if [ "$pkg_status" == installed ]; then
        # echo "Package $pkg_name is already installed, skipping." 
        # continue
      # fi
     
      # rm -Rf "${pkg_name}"
      # rm -Rf "${pkg_name}-build"
      
      # echo "Downloading package $pkg_name ..."
      # wget -nc -q -O $pkg_name $furl
      
      # echo "Extracting package $pkg_name ..."
      # halogenzip ${pkg_name}
      # mkdir "${pkg_name}-build"
      # cd "${pkg_name}-build"
      
      # continue
      
      # echo "Patching ..."
      # # pre hook
      
      # echo "Configuring archives of $pkg_name ..."
      # echo $Conf
      # ../$pkg_name/configure $Conf CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS"
      
      # echo "Building package of $pkg_name ..."
      # echo "CFLAGS=$CFLAGS CXXFLAGS=$CXXFLAGS"
      # make CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS"
      
      # if [ "$_make_check" -eq "1" ]; then
	# return 1
      # fi
      
      # $Id=$Id+1
      # if [ $? -eq 0 ] ; then
        # echo "Installing package $pkg_name ..."
        # sudo make install
        # if [ $? -eq 0 ] ; then
          # sqlite3 $lib_path/remote.db "UPDATE base_packages SET status = 'Installed' WHERE id = $Id";
        # else
          # echo "$pkg_name - make install failed!"
          # exit 1
        # fi
      # else
        # echo "$pkg_name - make check failed!"
        # exit 1
      # fi
      
      # cd /tmp/halogen
    # done
    # exit 0;;
  # optimize-debian)
    # query="SELECT packages FROM packages_base_debian WHERE 1"
    # commit=`sqlite3 $lib_path/halogen.db "$query"`;
    
    # IFS=$'\n'
    # _lines=($commit)
    
    # for row in ${_lines[@]}; do 
      # query="SELECT opt FROM packages_base_debian WHERE packages='$row'"
      # export _opti=`sqlite3 $lib_path/halogen.db "$query"`;
      
      # IFS=$' '
      # _packages=($row)

      # for _package in ${_packages[@]}; do
        # cd $tmp_path
        
        # _query="SELECT EXISTS(SELECT 1 FROM packages_installed WHERE package = '$_package' LIMIT 1);"
        # _installed=`sqlite3 $lib_path/halogen.db "$_query"`;
        
        # echo "package = $_package - installed = $_installed - optimize = $_opti"
        
        # if [ "$_installed" -eq "1" ]; then
          # echo "$_package is already installed."
          # continue
        # fi
        
        # echo "fetching $_package .."
        # apt-src install $_package
        
        # unset $IFS
        # cd ${tmp_path}/${_package}*
        
        # if _make_build $_opti; then
          # echo
        # else
          # continue
        # fi
        # if _make_check; then
          # echo
        # else
          # continue
        # fi
        # if _make_install; then
          # sqlite3 $lib_path/halogen.db "INSERT INTO packages_installed (package) VALUES ('$_package')";
        # else
          # continue
        # fi
        # continue
      # done
    # done
    # exit 0 ;;
  resume)
    # resume where left
    exit ;;
  *)
    exit ;;
esac